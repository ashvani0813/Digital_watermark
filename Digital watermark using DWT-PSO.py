# -*- coding: utf-8 -*-
"""internship.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q_1OeufqC2_hoAWcU8viRN7OXsjaz450
"""

pip install pyswarms

# Importing The necessary files
import cv2
import pywt
from google.colab.patches import cv2_imshow
from google.colab import drive
import numpy as np
import matplotlib.pyplot as plt
import math
import os
import copy

def calculate_psnr(img1, img2):
    mse = np.mean((img1.astype(np.float64) - img2.astype(np.float64)) ** 2)
    if mse == 0:
        return float('inf')
    PIXEL_MAX = 255.0
    return 20 * math.log10(PIXEL_MAX / math.sqrt(mse))

def calculate_ncc(img1, img2):
    img1 = img1.astype(np.float64)
    img2 = img2.astype(np.float64)
    numerator = np.sum((img1 - np.mean(img1)) * (img2 - np.mean(img2)))
    denominator = np.sqrt(np.sum((img1 - np.mean(img1)) ** 2) * np.sum((img2 - np.mean(img2)) ** 2))
    return numerator / denominator if denominator != 0 else 0

def calculate_ber(wm1, wm2):
    # Ensure binary (0/1) format
    wm1_bin = (wm1 > 127).astype(np.uint8)
    wm2_bin = (wm2 > 127).astype(np.uint8)

    total_bits = wm1_bin.size
    bit_errors = np.sum(wm1_bin != wm2_bin)

    return bit_errors / total_bits



# Mount Google Drive
drive.mount('/content/drive')
# os.makedirs('/content/drive/MyDrive/dwt', exist_ok=True)

cover_path = '/content/drive/MyDrive/dwt/lena.png'
watermark_path = '/content/drive/MyDrive/dwt/watermark.png'
output_path = '/content/drive/MyDrive/dwt/watermarked.png'

# Read cover (host) and watermark images in grayscale
cover = cv2.imread(cover_path, cv2.IMREAD_GRAYSCALE)
watermark = cv2.imread( watermark_path, cv2.IMREAD_GRAYSCALE)

if cover is None:
    raise FileNotFoundError("Cover image not found at the specified path.")
if watermark is None:
    raise FileNotFoundError("Watermark image not found at the specified path.")

cover = cv2.resize(cover, (256, 256))
host=copy.deepcopy(cover)
watermark = cv2.resize(watermark, (256, 256))

cv2_imshow(cover)

cv2_imshow(watermark)

print(cover.shape)
print(cover[:5, :5])

print(watermark.shape)
print(watermark[:5, :5])

# Ensure images are read correctly
if cover is None or watermark is None:
    raise Exception("Could not read input images.")

# Convert watermark to binary (0 or 255)
import copy
_, watermark_binary = cv2.threshold(watermark, 127, 255, cv2.THRESH_BINARY)
watermark_b = copy.deepcopy(watermark_binary.astype('float')/255.0)

print(np.max(watermark_b))

cv2_imshow(watermark_binary)
print(watermark_binary.shape)

cover=cover.astype('float')
cover /= 255.0
Transformed_coeffs_cover = pywt.wavedec2(cover, 'haar', level=3)
cA = Transformed_coeffs_cover[0]
originalcA=cA.copy()                                # required for extraction
(cH3,cV3, cD3) = Transformed_coeffs_cover[-3]
(cH2, cV2, cD2) = Transformed_coeffs_cover[-2]
(cH1, cV1, cD1) = Transformed_coeffs_cover[-1]

#plotting wavelet coefficients of level 3
plt.figure(figsize=(6,6))
plt.subplot(2,2,1)
plt.imshow(cA, cmap = plt.cm.gray)
plt.title('cA3: Approximate Details coeff.', fontsize=10)

plt.subplot(2,2,2)
plt.imshow(cH3,cmap = plt.cm.gray)
plt.title('cH3: Horizontal Details coeff.', fontsize=10)

plt.subplot(2,2,3)
plt.imshow(cV3, cmap=plt.cm.gray)
plt.title('cV3: Vertical Detailed coeff.', fontsize=10)

plt.subplot(2,2,4)
plt.imshow(cD3, cmap=plt.cm.gray)
plt.title('cD3: Diagonal Detailed coeff.', fontsize=10)

plt.show()

# Step 2: Resize watermark to match HH shape
wm_resized = cv2.resize(watermark_b, (cA.shape[1], cA.shape[0]))

print(wm_resized[:5, :5])

print(wm_resized.shape)

# Step 3: Embed the binary watermark into the HH sub-band

alpha = 0.1  # watermark strength
cA_embedded = cA + alpha * wm_resized

print(cA_embedded[:5, :5])

print(cA_embedded.shape)

cv2_imshow(cA_embedded*255)

Transformed_coeffs_cover[0]=cA_embedded
watermarked_img=pywt.waverec2(Transformed_coeffs_cover, 'haar')
watermarked_img=np.ceil(watermarked_img*255)
watermarked_img = np.uint8(np.clip(watermarked_img, 0, 255))

cv2_imshow(watermarked_img)

print(watermarked_img[:4, :4])
print(watermarked_img.shape)

# Save the watermarked image
cv2.imwrite(output_path, watermarked_img)

#plotting wavelet coefficients of level 3
plt.figure(figsize=(8,8))
plt.subplot(1,2,1)
plt.imshow(cover, cmap = plt.cm.gray)
plt.title('Original', fontsize=10)
plt.axis('off')

plt.subplot(1,2,2)
plt.imshow(watermarked_img,cmap = plt.cm.gray)
plt.title('Reconstructed', fontsize=10)
plt.axis('off')
plt.show()

"""### **Compute PSNR and SSIM**"""

# === Compute PSNR between original cover and watermarked image ===
psnr_value = calculate_psnr(host, watermarked_img)
print(f"PSNR between cover and watermarked image: {psnr_value:.2f} dB")

# from skimage.metrics import peak_signal_noise_ratio
from skimage.metrics import structural_similarity
# psnr=peak_signal_noise_ratio(cover, watermarked_img)
ssim=structural_similarity(host, watermarked_img)
print(f"SSIM between cover and watermarked image: {ssim:.2f}")

"""### **Extraction**"""

watermarked_img=watermarked_img.astype('float')
watermarked_img /= 255.0
Transformed_coeffs_wm = pywt.wavedec2(watermarked_img, 'haar', level=3)
cA_wm = Transformed_coeffs_wm[0]
(cH3,cV3, cD3) = Transformed_coeffs_wm[-3]
(cH2, cV2, cD2) = Transformed_coeffs_wm[-2]
(cH1, cV1, cD1) = Transformed_coeffs_wm[-1]

# Step 5: Extract watermark
extracted_wm = np.around(np.absolute(cA_wm - originalcA) / alpha)
# extracted_wm = np.clip(extracted_wm, 0, 255)
extracted_wm = np.uint8(extracted_wm*255)

print(extracted_wm[:4, :4])
print(extracted_wm.shape)

cv2_imshow(extracted_wm)

# # Step 6 (optional): Re-binarize the extracted watermark
_, extracted_binary = cv2.threshold(extracted_wm, 127, 255, cv2.THRESH_BINARY)

# Save both grayscale and binary extracted watermark
cv2.imwrite('extracted_gray.png', extracted_wm)
# cv2.imwrite('extracted_binary.png', extracted_binary)

# # Resize the embedded watermark to match extracted watermark
embedded_binary = cv2.resize(watermark_binary, extracted_binary.shape[::-1])

# Calculate BER and NCC between embedded and extracted watermarks
ber_value = calculate_ber(embedded_binary, extracted_binary)
ncc_embedded_vs_extracted = calculate_ncc(embedded_binary, extracted_binary)

print(f"BER between embedded and extracted watermark: {ber_value:.4f}")
print(f"NCC between embedded and extracted watermark: {ncc_embedded_vs_extracted:.4f}")

# Convert images to displayable formats
embedded_display = np.uint8(np.clip(embedded_binary, 0, 255))
extracted_display = np.uint8(np.clip(extracted_binary, 0, 255))

# Plot embedded vs extracted watermark
plt.figure(figsize=(10, 4))

plt.subplot(1, 2, 1)
plt.title("Embedded Watermark")
plt.imshow(embedded_display, cmap='gray')
#plt.axis('off')
plt.subplot(1, 2, 2)
plt.title("Extracted Watermark")
plt.imshow(extracted_display, cmap='gray')
plt.axis('on')

plt.subplot(1, 2, 2)
plt.title("Extracted Watermark")
plt.imshow(extracted_display, cmap='gray')
plt.axis('on')

plt.tight_layout()
plt.show()

# Plot BER and NCC as bar chart
plt.figure(figsize=(6, 4))
metrics = ['BER', 'NCC']
values = [ber_value, ncc_embedded_vs_extracted]

# Normalize PSNR for plotting  â€” divide by 100 to fit on same axis

bars = plt.bar(metrics, values, color=['blue', 'green', 'red'])

from skimage.metrics import structural_similarity

def evaluate_dwt_levels(cover, watermark_b, watermark_binary, host, alpha=0.1, level=1):
    results = []

    for level in range(1, 5):  # DWT levels 1 to 4
        # Step 1: Apply DWT
        coeffs_cover = pywt.wavedec2(cover, 'haar', level=level)
        cA = coeffs_cover[0]
        originalcA = cA.copy()

        # Step 2: Resize watermark to match cA
        wm_resized = cv2.resize(watermark_b, (cA.shape[1], cA.shape[0]))

        # Step 3: Embed watermark into cA
        cA_embedded = cA + alpha * wm_resized
        coeffs_cover[0] = cA_embedded

        # Step 4: Reconstruct watermarked image
        watermarked_img = pywt.waverec2(coeffs_cover, 'haar')
        watermarked_img = np.clip(np.ceil(watermarked_img * 255), 0, 255).astype(np.uint8)

        # Step 5: Compute PSNR and SSIM
        psnr_val = calculate_psnr(host, watermarked_img)
        ssim_val = structural_similarity(host, watermarked_img)

        # Step 6: Extract watermark
        watermarked_norm = watermarked_img.astype('float') / 255.0
        coeffs_wm = pywt.wavedec2(watermarked_norm, 'haar', level=level)
        cA_wm = coeffs_wm[0]
        extracted = np.around(np.abs(cA_wm - originalcA) / alpha)
        extracted = np.uint8(np.clip(extracted * 255, 0, 255))

        _, extracted_binary = cv2.threshold(extracted, 127, 255, cv2.THRESH_BINARY)
        wm_resized_bin = cv2.resize(watermark_binary, extracted_binary.shape[::-1])

        # Step 7: Calculate BER & NCC
        ber_val = calculate_ber(wm_resized_bin, extracted_binary)
        ncc_val = calculate_ncc(wm_resized_bin, extracted_binary)

        # Save results
        results.append((level, psnr_val, ssim_val, ber_val, ncc_val))

    return results

results = evaluate_dwt_levels(cover, watermark_b, watermark_binary, host, alpha=0.1)

# Display results
print(f"{'DWT Level':<10} {'PSNR (dB)':<10} {'SSIM':<10} {'BER':<10} {'NCC':<10}")
for res in results:
    print(f"{res[0]:<10} {res[1]:<10.2f} {res[2]:<10.4f} {res[3]:<10.4f} {res[4]:<10.4f}")

def pso_objective_levels(alpha_array, cover, watermark_b, watermark_binary, host):
    results = []
    for alpha in alpha_array:
        metrics = evaluate_dwt_levels(cover, watermark_b, watermark_binary, host, alpha=alpha, level=1)
        ssim_val = metrics[0][2]
        ber_val  = metrics[0][3]
        ncc_val  = metrics[0][4]

        # We want high SSIM, NCC and low BER => maximize (SSIM + NCC + (1 - BER))
        objective = - ( ssim_val + ncc_val ) /2 # Negative for minimization
        results.append(objective)
    return np.array(results)

# Run PSO with better objective and constrained bounds
from pyswarms.single import GlobalBestPSO

options = {'c1': 0.5, 'c2': 0.3, 'w': 0.9}
bounds = ([0.05], [0.2])  # Better alpha range for visibility + robustness

optimizer = GlobalBestPSO(n_particles=10, dimensions=1, options=options, bounds=bounds)

cost, pos = optimizer.optimize(pso_objective_levels, iters=10,
    cover=cover,
    watermark_b=watermark_b,
    watermark_binary=watermark_binary,
    host=host
)

optimal_alpha = pos[0]
print(f"\n Optimal alpha from PSO: {optimal_alpha:.4f}")

# === Apply Optimal Alpha to Final Embedding ===

# Step 1: DWT
Transformed_coeffs_cover = pywt.wavedec2(cover, 'haar', level=3)
cA = Transformed_coeffs_cover[0]
originalcA = cA.copy()

# Step 2: Resize watermark
wm_resized = cv2.resize(watermark_b, (cA.shape[1], cA.shape[0]))

# Step 3: Embed
cA_embedded = cA + optimal_alpha * wm_resized
Transformed_coeffs_cover[0] = cA_embedded

# Step 4: Reconstruct
watermarked_img = pywt.waverec2(Transformed_coeffs_cover, 'haar')
watermarked_img = np.uint8(np.clip(np.ceil(watermarked_img * 255), 0, 255))

# Step 5: Save and Show
cv2.imwrite(output_path, watermarked_img)
cv2_imshow(watermarked_img)

# === Quality Metrics ===
psnr_value = calculate_psnr(host, watermarked_img)
ssim = structural_similarity(host, watermarked_img)
print(f"ðŸ“Š PSNR: {psnr_value:.2f} dB")
print(f"ðŸ“Š SSIM: {ssim:.4f}")

# --- Extraction ---
# Get the DWT coefficients of the watermarked image
watermarked_norm = watermarked_img.astype('float') / 255.0
Transformed_coeffs_wm = pywt.wavedec2(watermarked_norm, 'haar', level=3)
cA_wm = Transformed_coeffs_wm[0]

# Calculate the difference, which should be the watermark signal
extracted_signal = np.absolute(cA_wm - originalcA)
threshold = np.max(extracted_signal) * 0.5  # You may need to tune this threshold

# Extract the binary watermark
extracted_binary = (extracted_signal > threshold).astype(np.uint8) * 255

# Resize embedded for comparison
embedded_binary = cv2.resize(watermark_binary, extracted_binary.shape[::-1])

# Final BER and NCC
ber_value = calculate_ber(embedded_binary, extracted_binary)
ncc_val = calculate_ncc(embedded_binary, extracted_binary)

print(f"ðŸ“Š BER: {ber_value:.4f}")
print(f"ðŸ“Š NCC: {ncc_val:.4f}")

# === Display Embedded vs Extracted Watermark ===
plt.figure(figsize=(10, 4))

plt.subplot(1, 2, 1)
plt.title("Embedded Watermark")
plt.imshow(embedded_binary, cmap='gray')
plt.axis('off')

plt.subplot(1, 2, 2)
plt.title("Extracted Watermark")
plt.imshow(extracted_binary, cmap='gray')
plt.axis('off')

plt.tight_layout()
plt.show()

